{
  "blogTitle": "Тех Блог Хусниддина",
  "navigateToAngularSetterGetter": "Setter и Getter в Angular",
  "powerOfGettersAndSetters": "Сила геттеров и сеттеров в TypeScript",
  "setterGetter": {
    "title": "Использование сеттера и геттера в Angular",
    "intro": "Мы используем геттер и сеттер для отслеживания изменений свойства @Input в Angular. Существует также другой способ — NgOnChanges, о котором мы поговорим позже в статье.",
    "childIntro": "В дочернем компоненте:",
    "parentIntro": "В родительском компоненте:",
    "whatIsHappeningTitle": "Что происходит",
    "whatIsHappening": "В этой настройке дочерний компонент создаёт объект, а родительский компонент может изменить значение этого объекта с помощью кнопок (Messi или Ronaldo). Поскольку первоначальное имя игрока установлено в null, имя не отображается на экране до нажатия кнопки."
  },
  "powerGetters": {
    "title": "Возможности геттеров и сеттеров в TypeScript",
    "intro": "Когда мы работаем с классами в объектно-ориентированном программировании, инкапсуляция является ключевым понятием. Она заключается в объединении данных (свойств) и методов, работающих с этими данными, в единый блок — класс. Часть этого процесса — контроль доступа к внутреннему состоянию класса. Давайте посмотрим, почему это важно и как геттеры и сеттеры помогают в этом.",
    "challengeTitle": "Проблема: прямой доступ и его подводные камни",
    "challengeDesc": "Представьте, что у нас есть простой класс Product:",
    "solutionTitle": "Решение: введение геттеров и сеттеров",
    "solutionIntro": "Именно здесь геттеры и сеттеры проявляют свои сильные стороны! Это специальные методы, которые обеспечивают чтение и запись свойств объекта, позволяя добавлять логику перед возвратом или установкой значения.",
    "solutionDetail": "Давайте рефакторим наш класс Product. По соглашению мы будем префиксировать приватное свойство знаком подчёркивания (например, _id) и определим публичные аксессоры get и set для него:",
    "solutionAfterCode": "Теперь, когда вы пишете bread.id = 2;, вы не получаете доступ напрямую к полю, а вызываете метод set id(newId: number). Аналогично, чтение bread.id вызывает метод get id(): number. Это работает без проблем и позволяет включать логику — проверку или логирование — внутри этих аксессоров.",
    "whyBotherTitle": "Зачем это нужно?",
    "reasonEncapsulation": "<strong>Инкапсуляция:</strong> защищает внутреннее состояние объекта.",
    "reasonControlledAccess": "<strong>Контролируемый доступ:</strong> вы определяете, как свойства читаются и записываются.",
    "reasonValidation": "<strong>Проверка данных (Validation):</strong> выполняйте проверки перед изменением значения свойства (например, проверка на положительный ID).",
    "reasonComputedProperties": "<strong>Вычисляемые свойства:</strong> геттеры могут возвращать значения, вычисленные на основе других свойств.",
    "reasonSideEffects": "<strong>Побочные эффекты (Side Effects):</strong> выполнение действий (например, логирование или вызов событий) при доступе или изменении свойства.",
    "concluding": "Геттеры и сеттеры — это фундаментальные инструменты для создания надёжных, поддерживаемых и гибких классов в TypeScript и многих других ООП-языках. Они позволяют предоставить чистый публичный API, сохраняя внутреннюю логику класса скрытой."
  }

}
