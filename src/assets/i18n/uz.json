{
  "blogTitle": "Xusniddinning Tex Blogi",
  "navigateToAngularSetterGetter": "Angularda Setter va Getter",
  "powerOfGettersAndSetters": "TypeScript'da Getter va Setterlarning Kuchi",
  "setterGetter": {
    "title": "Angularda setter va getter foydalanish holati",
    "intro": "<code>Getter</code> va <code>setter</code>dan Angular’da <code>@Input</code> xossasiga o‘zgarishlarni aniqlash uchun foydalanamiz. Buning uchun yana bir usul — <code>NgOnChanges</code>, bu haqda maqolada keyinroq gaplashamiz.",
    "childIntro": "Child komponentida:",
    "parentIntro": "Parent komponentida:",
    "whatIsHappeningTitle": "Nima bo‘lmoqda",
    "whatIsHappening": "Ushbu tuslamada Child komponent obyektni yaratadi, Parent komponent esa tugmalar yordamida (Messi yoki Ronaldo) obyekt qiymatini o‘zgartira oladi. Dastlabki o‘yinchi nomi <code>null</code> ga tenglangani uchun tugma bosilmaguncha nom ekranda ko‘rinmaydi."
  },
  "powerGetters": {
    "title": "TypeScriptdagi getter va setterlarning imkoniyatlari",
    "intro": "Ob’ektga yo’naltirilgan dasturlashda <code>sinflar</code> bilan ishlaganda, kapsulalash (enkapsulyatsiya) asosiy tushunchalardan biridir. Bu, ma’lumotlarni (<code>xususiyatlar</code>) va ularni qayta ishlaydigan <code>metodlarni</code> bitta birlik — <code>sinf</code> ichida birlashtirishni anglatadi. Bunga <code>sinfning</code> ichki holatiga kirishni nazorat qilish ham kiradi. Keling, buning nima uchun muhimligini va <code>getter</code> hamda <code>setterlar</code> qanday yordam berishini ko‘rib chiqaylik.",
    "challengeTitle": "Muammo: To‘g‘ridan-to‘g‘ri kirish va uning salbiy oqibatlari",
    "challengeDesc": "Tasavvur qiling, bizda oddiy <code>Product</code> sinfi bor:",
    "solutionTitle": "Yechim: Getter va setterlarni joriy etish",
    "solutionIntro": "<code>Getter</code> va <code>setterlar</code> aynan shu vazifani bajaradi! Ular ob’ekt <code>xususiyatlariga</code> o‘qish va yozish uchun <code>usullar</code> bo‘lib, qiymatni qaytarish yoki o‘rnatishdan oldin lo‘gika qo‘shishga imkon beradi.",
    "solutionDetail": "Keling, <code>Product</code> sinfimizni qayta tuzamiz. Biz <code>maxfiy</code> xususiyat nomini oldiga chiziqli pastki chiziq (<code>_</code>) qo‘yamiz (masalan, <code>_id</code>) va unga mos <code>public</code> <code>get</code> hamda <code>set</code> accessorlarini belgilaymiz:",
    "solutionAfterCode": "Endi <code>bread.id = 2;</code> yozganingizda xususiyatga to‘g‘ridan-to‘g‘ri emas, balki <code>set id(newId: number)</code> metodiga murojaat qilasiz. Xuddi shunday, <code>bread.id</code> ni o‘qiganingizda <code>get id(): number</code> metodi chaqiriladi. Bu to‘liq muammosiz ishlaydi va bizga validatsiya yoki loglash kabi lo‘gikani bu accessorlar ichiga qo‘shish imkonini beradi.",
    "whyBotherTitle": "Nega buni qilish kerak?",
    "reasonEncapsulation": "<strong>Kapsulalash (Encapsulation):</strong> Ob’ektning ichki holatini himoya qiladi.",
    "reasonControlledAccess": "<strong>Nazorat qilingan kirish:</strong> <code>Xususiyatlarni</code> qanday o‘qish va o‘zgartirishni siz belgilaysiz.",
    "reasonValidation": "<strong>Ma’lumotni tekshirish (Validatsiya):</strong> <code>Xususiyat</code> qiymati o‘zgartirilishidan oldin tekshiruvlarni amalga oshiring (masalan, ijobiy ID tekshiruvi).",
    "reasonComputedProperties": "<strong>Hisoblangan xususiyatlar:</strong> <code>Getterlar</code> boshqa <code>xususiyatlardan</code> hosil bo‘lgan qiymatlarni qaytarishi mumkin.",
    "reasonSideEffects": "<strong>Yon ta’sirlar (Side Effects):</strong> <code>Xususiyatga</code> murojaat yoki o‘zgartirilganda loglash yoki hodisalar chaqirish kabi amallarni bajaradi.",
    "concluding": "<code>Getter</code> va <code>setterlar</code> TypeScript va boshqa ob’yektga yo‘naltirilgan tillarda mustahkam, oson saqlanadigan va moslashuvchan <code>sinflar</code> yaratish uchun zarur vositalardir. Ular <code>sinf</code> ichki ishlarini yashirgan holda toza umumiy <code>API</code> ni taqdim etishga yordam beradi."
  },
  "controlFlow": {
  "title": "Angular boshqaruv oqimi: *ngIf vs @if, *ngFor vs @for va @switch",
  "intro": "Angularda shartli va ro'yxatni render qilish uchun an'anaviy <code>*ngIf</code>, <code>*ngFor</code> va <code>[ngSwitch]</code> direktivalari ishlatiladi. V16 dan esa <code>@if</code>, <code>@for</code> va <code>@switch</code> sintaksislari paydo bo'ldi – ular JavaScript ga o'xshash, kamroq kod bilan, o'qilishi qulay yechim taqdim etadi.",
  "ifVsNgIfTitle": "*ngIf vs @if",
  "ifVsNgIfDesc": "<code>*ngIf</code> Angularning standart struktural direktivasi bo'lib, shartga qarab shablonni qo'shadi yoki olib tashlaydi. <code>@if</code> esa xuddi JS sintaksisiday shartni yozishga imkon beradi.",
  "nestedIfDesc": "<code>*ngIf</code> bilan <code>ng-template</code> yordamida <code>else</code> blokiga murojaat qilinadi, <code>@if</code> da esa <code>@else</code> ni to'g'ridan-to'g'ri bir blok ichida yozasiz.",
  "forVsNgForTitle": "*ngFor vs @for",
  "forVsNgForDesc": "<code>*ngFor</code> kolleksiyani aylantirib chiqadi. <code>@for</code> esa yanada toza sintaksis beradi va <code>@empty</code> bilan bo'sh holatni ham tekshiradi.",
  "trackFeatureTitle": "Optimallashtirish: track vs trackBy",
  "trackFeatureDesc": "<code>*ngFor</code> da <code>DOM</code> yangilanishini optimallashtirish uchun <code>trackBy</code> funksiyasini uzatasiz. <code>@for</code> da esa sikl boshi deklaratsiyasiga <code>track item.id</code> qo'shish kifoya.",
  "switchVsNgSwitchTitle": "*ngSwitch vs @switch",
  "switchVsNgSwitchDesc": "<code>*ngSwitch</code> shablonda <code>switch-case-default</code> tuzilmasini beradi. <code>@switch</code> esa xuddi JavaScript dagi kabi <code>@case</code> va <code>@default</code> yozishga imkon beradi.",
  "conclusion": "Angular v16 bilan kelgan <code>@if</code>, <code>@for</code>, <code>@switch</code> direktivalari an'anaviy <code>*ngIf</code>, <code>*ngFor</code> va <code>[ngSwitch]</code> ni to'ldiradi, kod hajmini kamaytiradi va shablonlarni o'qishni osonlashtiradi."
}
}
